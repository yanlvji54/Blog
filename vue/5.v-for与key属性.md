# v-for 与 key

v-for 的书写过程中，一般默认会要求同步书写:key 属性，问题来了，key 属性做了什么，它是非必要的吗？

## 经典 bug

在没有 key 属性的情况下：
在一个循环渲染的列表中，我把第二个删除了，会发生什么事？

Vue 会认为你做了两件事： 把 2 变成了 3， 把 3 删除了。
在无额外状态的情况下，现在的做法“看起来”并无问题，但是如果有一个额外状态，则会导致与额外状态的对应不一致。
本在 2 的额外状态被保留了，而在 3 处的额外状态被干掉了。

为什么？

Vue 对与 v-for 的默认更新机制，即未输入 key 属性情况的更新机制是“就地更新”。新老数组在循环时一一对应更新。
即使下一个节点就是与自己完全相同的，它也不会采取常规的检测更新，因为 v-for 创造的节点没有给予相应的 id 值。

## v-for 中加入 key 的本质

v-for 中加入 key 的作用实际上需要动态情况才会有它的作用。
即处在存在 dom 节点变化的循环中才有存在的意义
原来有许多地方常用以下**错误代码**：
···

  <!-- 错误写法 -->
  <div>
    <div v-for="(item, index) in list" :key="index" />
  </div>
···

这样的写法实际上是没有任何意义的，反而有可能会降低 vue 设定的优化机制，导致负优化。
在 ESLINT 的设置中，大部分会把 v-for 必须带有 key 的设定加入。这样的好处是避免掉“本地更新”容易导致的恶性 bug。
但其实以上的写法也并不能避免上述 bug 的产生。

## v-for 中 key 的规则

key 是一个唯一值，作用是对比数据的更新。 vue 对于有无 key 的 v-for 循环更新的处理方案是不同的。在有 key 的情况下，是通过 key 的对比以达到准确更新的目的。这也是为什么在 key 中用 index 是无意义的。因为 index 会随着 data 节点的变化而变化。在第一个节点被删除后，原来的二节点对应的 index 变成 1 了。这会导致 vue 遵循 key 更新策略，依旧把本该在 2 处更新的值错误的更新在 1 节点处。

对于程序的操作流程： 删除 2 节点 -> index 从 1，2，3 变成 1，2 -> 得出删除 3 节点。
依旧触发了上述恶性 bug。

对于 key 的设置， 如果列表中存在唯一 id 值， 直接使用即可，若无相应 ID 值， 则可以使用相应 id 类库生成一个。
原则上来说，非展示数据不会有太大的数据量，如果存在此类问题，用 id 生成的方式造成的性能消耗也很有限。

## v-for 处理方案

如果 v-for 仅用来展示（即不涉及 v-for 循环的个数变动），其实去掉 key 属性也是一个比较好的写法。建议如果有如此情况，可以用忽略注释特别注解相应的行数。一可以提高系统效率，二也可以有更好的语义化，三也可以达到 eslint 提醒的作用。
